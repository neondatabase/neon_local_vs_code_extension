import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';

export interface MigrationFile {
    id: string;
    name: string;
    type: 'migration' | 'query' | 'seed';
    path: string;
    relativePath: string;
    framework?: string;
    timestamp?: string;
    status?: 'pending' | 'executed' | 'unknown';
}

export interface MigrationFolder {
    id: string;
    name: string;
    path: string;
    relativePath: string;
    framework?: string;
    files: MigrationFile[];
}

export class MigrationScannerService {
    private watchers: vscode.FileSystemWatcher[] = [];

    /**
     * Common exclusion patterns for generated files and build artifacts
     */
    private readonly EXCLUSION_PATTERN = '{**/node_modules/**,**/dist/**,**/build/**,**/out/**,**/.next/**,**/.nuxt/**,**/target/**,**/.build/**,**/__pycache__/**,**/.pytest_cache/**,**/venv/**,**/.venv/**,**/env/**,**/.env/**,**/virtualenv/**,**/.virtualenv/**,**/generated/**,**/.generated/**,**/__generated__/**,**/.git/**,**/.cache/**,**/.parcel-cache/**,**/coverage/**,**/.coverage/**,**/.nyc_output/**,**/prisma/generated/**,**/@generated/**,**/vendor/**,**/.bundle/**,**/.gradle/**,**/tmp/**,**/.tmp/**,**/.temp/**,**/.vscode/**,**/.idea/**,**/Library/**,**/lib/python*/**,**/site-packages/**}';

    /**
     * Check if file is a framework migration that should be included despite generated markers
     */
    private isFrameworkMigration(filePath: string): boolean {
        const pathLower = filePath.toLowerCase();
        
        // Django migrations
        if (pathLower.includes('/migrations/') && filePath.endsWith('.py')) {
            return true;
        }
        
        // Rails migrations
        if (pathLower.includes('/db/migrate/') && filePath.endsWith('.rb')) {
            return true;
        }
        
        // Laravel migrations
        if (pathLower.includes('/database/migrations/') && filePath.endsWith('.php')) {
            return true;
        }
        
        // Prisma migrations
        if (pathLower.includes('/prisma/migrations/') && filePath.endsWith('.sql')) {
            return true;
        }
        
        // TypeORM/Sequelize/Knex migrations
        if ((pathLower.includes('/migrations/') || pathLower.includes('/migration/')) && 
            (filePath.endsWith('.ts') || filePath.endsWith('.js'))) {
            return true;
        }
        
        // Flyway migrations
        if (pathLower.includes('/db/migration/') && filePath.endsWith('.sql')) {
            return true;
        }
        
        return false;
    }

    /**
     * Check if a file appears to be generated based on content markers
     */
    private async isGeneratedFile(filePath: string): Promise<boolean> {
        // Don't filter out framework migrations even if they have "generated" markers
        if (this.isFrameworkMigration(filePath)) {
            return false;
        }
        
        try {
            const content = await fs.promises.readFile(filePath, 'utf8');
            const firstLines = content.split('\n').slice(0, 10).join('\n').toLowerCase();
            
            // Common markers for generated files
            const generatedMarkers = [
                '@generated',
                'auto-generated',
                'autogenerated',
                'automatically generated',
                'do not edit',
                'do not modify',
                'code generated',
                'generated by',
                'this file is generated',
                'warning: this file is automatically generated',
                '# <autogenerated />',
                '// <auto-generated>',
                '<!-- generated -->',
                'prisma/client',
            ];

            return generatedMarkers.some(marker => firstLines.includes(marker));
        } catch {
            return false;
        }
    }

    /**
     * Check if file is inside a Python virtual environment
     */
    private isInVirtualEnv(filePath: string): boolean {
        const pathLower = filePath.toLowerCase();
        
        // Check for site-packages (definitive indicator of Python venv)
        if (pathLower.includes('/site-packages/') || pathLower.includes('\\site-packages\\')) {
            return true;
        }
        
        // Check for lib/pythonX.X pattern (Unix venv structure)
        if (/\/lib\/python\d+\.\d+\//i.test(filePath)) {
            return true;
        }
        
        // Check for common venv folder names followed by lib/python
        if (/\/(venv|\.venv|env|\.env|virtualenv|\.virtualenv)[\/\\].*[\/\\]lib[\/\\]python/i.test(filePath)) {
            return true;
        }
        
        // Check for Scripts folder (Windows venv structure)
        if (/\/(venv|\.venv|env|\.env|virtualenv|\.virtualenv)[\/\\]Scripts[\/\\]/i.test(filePath)) {
            return true;
        }
        
        // Check for Lib folder (Windows venv structure)
        if (/\/(venv|\.venv|env|\.env|virtualenv|\.virtualenv)[\/\\]Lib[\/\\]/i.test(filePath)) {
            return true;
        }
        
        return false;
    }

    /**
     * Check if a file path contains indicators of being generated
     */
    private isGeneratedPath(filePath: string): boolean {
        // First check for virtual environment (most common false positive)
        if (this.isInVirtualEnv(filePath)) {
            return true;
        }
        
        const pathLower = filePath.toLowerCase();
        const generatedPathSegments = [
            '/generated/',
            '/.generated/',
            '/__generated__/',
            '/@generated/',
            '/prisma/generated/',
            '/dist/',
            '/build/',
            '/out/',
            '/.next/',
            '/.nuxt/',
            '/target/',
            '/__pycache__/',
            '/node_modules/',
            '/vendor/',
            '/coverage/',
            '/.cache/',
            '/.vscode/',
            '/.idea/',
        ];

        return generatedPathSegments.some(segment => pathLower.includes(segment));
    }

    /**
     * Scan workspace for migration files and SQL queries
     */
    async scanWorkspace(): Promise<MigrationFolder[]> {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders || workspaceFolders.length === 0) {
            return [];
        }

        const folders: MigrationFolder[] = [];

        for (const workspaceFolder of workspaceFolders) {
            const workspacePath = workspaceFolder.uri.fsPath;
            
            // Scan for common migration patterns
            const migrationPatterns = [
                // Knex
                { pattern: '**/migrations/*.{js,ts,sql}', framework: 'Knex', folderName: 'migrations' },
                { pattern: '**/db/migrate/*.{rb,sql}', framework: 'Rails', folderName: 'db/migrate' },
                { pattern: '**/database/migrations/*.{php,sql}', framework: 'Laravel', folderName: 'database/migrations' },
                // Sequelize
                { pattern: '**/migrations/*.{js,ts}', framework: 'Sequelize', folderName: 'migrations' },
                // TypeORM
                { pattern: '**/migration/*.{js,ts}', framework: 'TypeORM', folderName: 'migration' },
                // Prisma
                { pattern: '**/prisma/migrations/*/*.sql', framework: 'Prisma', folderName: 'prisma/migrations' },
                // Flyway
                { pattern: '**/db/migration/*.sql', framework: 'Flyway', folderName: 'db/migration' },
                // Liquibase
                { pattern: '**/db/changelog/*.{sql,xml,json,yaml,yml}', framework: 'Liquibase', folderName: 'db/changelog' },
                // Django
                { pattern: '**/migrations/*.py', framework: 'Django', folderName: 'migrations' },
                // Generic SQL queries
                { pattern: '**/queries/*.sql', framework: null, folderName: 'queries' },
                { pattern: '**/sql/*.sql', framework: null, folderName: 'sql' },
                { pattern: '**/scripts/*.sql', framework: null, folderName: 'scripts' },
                // Seeds
                { pattern: '**/seeds/*.{js,ts,sql}', framework: null, folderName: 'seeds' },
                { pattern: '**/seeders/*.{js,ts,sql}', framework: null, folderName: 'seeders' },
            ];

            for (const { pattern, framework, folderName } of migrationPatterns) {
                const files = await vscode.workspace.findFiles(
                    new vscode.RelativePattern(workspaceFolder, pattern),
                    this.EXCLUSION_PATTERN
                );

                if (files.length > 0) {
                    // Group files by their directory
                    const filesByDir = new Map<string, vscode.Uri[]>();
                    
                    for (const file of files) {
                        const dir = path.dirname(file.fsPath);
                        if (!filesByDir.has(dir)) {
                            filesByDir.set(dir, []);
                        }
                        filesByDir.get(dir)!.push(file);
                    }

                    // Create folder entries
                    for (const [dir, dirFiles] of filesByDir) {
                        const relativePath = path.relative(workspacePath, dir);
                        const migrationFiles: MigrationFile[] = [];

                        for (const file of dirFiles) {
                            const fileName = path.basename(file.fsPath);
                            const fileRelativePath = path.relative(workspacePath, file.fsPath);
                            
                            // Skip if path indicates it's generated
                            if (this.isGeneratedPath(file.fsPath)) {
                                continue;
                            }
                            
                            // Skip if file content indicates it's generated
                            if (await this.isGeneratedFile(file.fsPath)) {
                                continue;
                            }
                            
                            // Determine file type
                            let fileType: 'migration' | 'query' | 'seed' = 'query';
                            if (relativePath.includes('migration') || relativePath.includes('migrate')) {
                                fileType = 'migration';
                            } else if (relativePath.includes('seed')) {
                                fileType = 'seed';
                            }

                            // Extract timestamp from filename if present
                            const timestampMatch = fileName.match(/^(\d{10,14})/);
                            const timestamp = timestampMatch ? timestampMatch[1] : undefined;

                            migrationFiles.push({
                                id: file.fsPath,
                                name: fileName,
                                type: fileType,
                                path: file.fsPath,
                                relativePath: fileRelativePath,
                                framework,
                                timestamp,
                                status: 'unknown'
                            });
                        }

                        // Sort by timestamp if available, otherwise by name
                        migrationFiles.sort((a, b) => {
                            if (a.timestamp && b.timestamp) {
                                return a.timestamp.localeCompare(b.timestamp);
                            }
                            return a.name.localeCompare(b.name);
                        });

                        folders.push({
                            id: dir,
                            name: relativePath || folderName,
                            path: dir,
                            relativePath,
                            framework: framework || undefined,
                            files: migrationFiles
                        });
                    }
                }
            }
        }

        // Deduplicate folders (in case multiple patterns matched the same directory)
        const uniqueFolders = new Map<string, MigrationFolder>();
        for (const folder of folders) {
            if (!uniqueFolders.has(folder.id)) {
                uniqueFolders.set(folder.id, folder);
            } else {
                // Merge files if folder already exists
                const existing = uniqueFolders.get(folder.id)!;
                const existingPaths = new Set(existing.files.map(f => f.path));
                for (const file of folder.files) {
                    if (!existingPaths.has(file.path)) {
                        existing.files.push(file);
                    }
                }
            }
        }

        return Array.from(uniqueFolders.values());
    }

    /**
     * Read SQL content from a file
     */
    async readFileContent(filePath: string): Promise<string> {
        try {
            const content = await fs.promises.readFile(filePath, 'utf8');
            return content;
        } catch (error) {
            throw new Error(`Failed to read file: ${error}`);
        }
    }

    /**
     * Watch for changes in migration directories
     */
    watchMigrations(onUpdate: () => void): void {
        // Clean up existing watchers
        this.dispose();

        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders) {
            return;
        }

        const patterns = [
            '**/migrations/**/*.{sql,js,ts}',
            '**/migration/**/*.{sql,js,ts}',
            '**/db/**/*.sql',
            '**/queries/**/*.sql',
            '**/sql/**/*.sql',
            '**/scripts/**/*.sql',
            '**/seeds/**/*.{sql,js,ts}',
            '**/seeders/**/*.{sql,js,ts}',
        ];

        for (const pattern of patterns) {
            const watcher = vscode.workspace.createFileSystemWatcher(pattern);
            watcher.onDidCreate(onUpdate);
            watcher.onDidDelete(onUpdate);
            watcher.onDidChange(onUpdate);
            this.watchers.push(watcher);
        }
    }

    /**
     * Cleanup watchers
     */
    dispose(): void {
        for (const watcher of this.watchers) {
            watcher.dispose();
        }
        this.watchers = [];
    }
}


